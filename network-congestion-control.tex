\documentclass[paper=a4,fontsize=12pt,ngerman]{scrartcl}

\usepackage[utf8]{inputenc}				
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage[a4paper,left=25mm,right=35mm,top=25mm,bottom=30mm]{geometry}
\usepackage{parskip}

\usepackage{tcolorbox}
\tcbuselibrary{listingsutf8}
\usepackage{listings}

\usepackage{amssymb}
\usepackage{cite}

\usepackage{verbatim} 
\usepackage{subcaption}  
\DeclareCaptionType{listing}[Listing][List of Listings]
\usepackage{float}

% für die komplexe table im Amhamng 
% https://mylatexnotes.wordpress.com/2017/07/31/text-x-mark-to-match-checkmark/
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{adjustbox}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}} 
\newcommand{\xmark}{\ding{55}} 



\begin{document}


\pagenumbering{roman}
\pagestyle{plain}



% Einbinden der Titelseite
\include{titleseite}

% Hier ist der Abstract
\section*{Abstract}



Dieser Bericht zielt darauf ab, aktuell benutzte Algorithmen der Netzwerkstaukontrolle in Computernetzwerken 
zu vergleichen.

Die Algorithmen der Staukontrolle, welche in diesen Vergleich einfließen sind : TCP BBR,
TCP NewReno, TCP Cubic, und TCP Vegas.  \newline

Mittels des Open-Source Netzwerksimulators \textit{NS-3}\cite{ns3-simu} wird ein virtuelles Netzwerk mit einer 10Mbit/s Engstelle zwischen zwei Endpunkten aufgestellt. 
In diesem Netzwerk wird zunächst ein künstlicher Datenverkehr erzeugt.
Der genannte Datenverkehr wird anschließend aufgezeichnet und das dabei entstehende \textit{Congestion Window}(CW) dient als Basis für den Vergleich.
Die unterschiedlichen CW's werden schließlich analysiert und in Bezug auf das gegebene Szenario evaluiert.
Dieser Bericht bietet dem Leser einen Überblick über einige CC-Algorithmen und ein grundlegendes Verständnis darüber, wie Computernetzwerke auf Datenstau und 
Paketverlust reagieren.




\newpage
\section*{Selbstständigkeitserklärung}
Ich versichere, dass ich die vorliegende Arbeit selbstständig verfasst und 
keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe.
Insbesondere habe ich alle KI-basierten Werkzeuge angegeben, die ich bei
der Erstellung, Übersetzung oder Überarbeitung des Textes verwendet habe.

Ich erkläre hiermit weiterhin, dass die vorgelegte Arbeit zuvor weder von mir 
noch von einer anderen Person an dieser oder einer anderen Hochschule 
eingereicht wurde.

Darüber hinaus ist mir bekannt, dass die Unrichtigkeit dieser Erklärung eine 
Benotung der Arbeit mit der Note \glqq nicht ausreichend\grqq \ zur Folge hat 
und einen Ausschluss von der Erbringung weiterer Prüfungsleistungen zur Folge 
haben kann.
\bigskip
 
Saarbrücken, den \today

\smallskip
Unterschrift  Micha\l{} Roziel




% Das Inhaltsverzeichnis
\clearpage
\tableofcontents 

\clearpage
\pagenumbering{arabic}

% Hier beginnt das erste Kapitel


\section{Einleitung}

Network congestion control (\textbf{CC}) ist ein essentieller Bestandteil der 
meisten modernen Computernetzwerke. 
Wenn eine Netzwerkschnittstelle zu einem Zeitpunkt versucht eine zu große Menge an Datenpaketen aufzunehmen,
kommt es zu Stau von Datenverkehr und zu einem potentiellen Verlust von Datenpaketen.
Aufgrund diesem Vorkommen werden Algorithmen innerhalb von Netzwerkprotokollen verwendet, diese erkennen den Anstau von Datenverkehr im Netzwerk,
und helfen den Fluss von Datenpaketen zu steuern. Neben dem effizienten Durchfluss von Informationen ist zeitgleich auch die Fairness, 
was die Verteilung von Ressourcen einer Netzwerkschnittstelle an ihre Hosts angeht, wichtig. Auch dies wird von CC-Algorithmen gewährleistet.
In dem heutigen Stand von Rechnernetzen werden verschiedene Protokolle zur Netzwerkstaukontrolle verwendet, 
Ich werde mich im Rahmen dieses Berichts allerdings auf das Transmission Control Protocoll beschränken, da dies das am meisten verbreitete ist.  \newline
\newline
Mit stets weiterentwickelten Rechnernetzen, und einem jährlich zunehmenden Datenverkehr, wie auch in der Deutschen Internetschnittstelle
\textit{DE-CIX}\cite{DE-CIX2025} in Frankfurt gewinnen diese Algorithmen an Bedeutung. 






\subsection{Grundlagen und Begriffe}
Um die Funktionsweise und den Unterschied zwischen den hier behandelten CC-Algorithmen verstehen zu können, muss der Leser erst ein Grundverständnis über die Kommunukation innerhalb von Computernetzwerken haben.
Grundsätzlich wird heutzutage eins von zwei am verbreitesten Protokollen verwendet, entweder 
TCP oder UDP. 

\subsubsection{Transmission Control Protocoll}

Das Transmission Control Protocoll (\textbf{TCP}) ist ein weit verbreitetes Netzwerkprotokoll. 
TCP lässt sich in zu der Schicht 4 (Transportschicht) in dem OSI-Modell einordnen, hierbei liegt es zwichen der Vermittlungs- und Kommunikationsschicht.
\newline TCP wurde 1981 unter RFC 793 erstmals standarisiert. \cite{rfc793}  \newline
Die Aufgabes des TCP Protokolls ist es, zwischen zwei Hosts eine Verbindung aufzubauen, welche anschließend dazu genutzt wird,  
Nachrichten in zu verschicken und zu empfangen.

% QUOTE
\begin{quote}
``transport-layer protocol [\dots] from an application’s perspective, it is as if 
the hosts running the processes were directly connected;'' \cite[241]{kr22}.      
\end{quote}


Dies Bedeutet, dass TCP ebenfalls eine gewisses Abstraktionsniveau
des Nachrichtenaustausches abnimmt. 


Ein klares Unterscheidungsmerkmal des TCP von dem ebenfalls bekannten User Datagramm Protocoll (UDP) ist, dass TCP verbindungsorientiert arbeitet, 
während UDP als verbindungslos gilt. Zudem werden bei TCP Daten in Form von Packets verschickt, während man bei UDP von Datagrammen spricht. \newline
Bei TCP wird zu Beginn ein \textit{Three-Way Handshake}
wie folgt durchgeführt : 

Der Sender schickt zunächst eine Nachricht mit einem Verbindungswunsch an den Empfänger und setzt das Flag 
\textit{Synchronize, \textbf{SYN}}.
\newline
Der Empfänger antwortet mit einer Bestätigung die erste Nachrichte erhalten zu haben, und schickt ebenfalls einen 
Verbindungswunsch. Es werden die Flags \textit{\textbf{SYN-ACK}} (Synchronise-Acknowledge) gesetzt.


Als letztes schickt der Sender eine Bestätigung, dass die Nachricht des Empfängers angekommen ist, dies geschieht wieder
mit dem Flag \textit{\textbf{ACK}}. Nun ist die Verbindung bereit, Daten in beide Richtungen zu übertragen.
Nach jedem gesendeten Datenpaket folgt eine \textit{\textbf{ACK}} Bestätigung.
\newline Die Abbildung \ref{fig:three-way handshake} im Anhang visualisiert den Three-Way Handshake.





\subsection{Algorithmen der Staukontrolle }

Algorithmen der Staukontrolle kommen zum Einsatz, wenn in einem Netzwerk ein potentieller Datenstau erkannt wird.
Grundsätzlich starten die Algorithmen in dem Arbeitsmodus \textit{slow start}.
Falls Datenstau erkannt wird, treten diese Algorithmen in die Phase \textit{congestion avoidance}.


Hiermit wird mit verschiedenen Vorgehensweisen gegen die Netzwerküberlastung gesteuert. 
\newline
Es existieren unterschiedliche Typen von CC-Algorithmen, die jeweils ihre eigenen Vor- und Nachteile haben.
In diesem Bericht wird jeweils ein Algorithmus pro Typ behandelt.





\subsubsection{TCP BBR} 
Der \textit{Bottleneck Bandwith and Round-Trip Time} (\textbf{BBR}) Algorithmus wurde erstmals in dem von der
\textit{Association for Computing Machinery} (\textbf{ACM}) veröffentlichten Magazin ACM vorgestellt. \cite{cardwell-iccrg-bbr-congestion-control-02}

Seit 2016 wurden 3 Versionen entwickelt. Diese werden jeweils mit \textit{BBRv\_x} gekennzeichnet, 
wobei \textit{x} die entsprechende Version beschreibt. 
BBR ist ein modellbasiertes Staukontrollverfahren, dessen Arbeitsweise in 4 Phasen
unterteilt werden kann : \newline

\begin{enumerate}
    \item \textit{STARTUP}(Startphase)
    \item \textit{DRAIN}(Abbau des Staus)
    \item \textit{ProbeBW}(Messen der Bandbreite)
    \item \textit{ProbeRTT}(Messen der Round-Trip-time)
\end{enumerate}


Während andere CC-Algorithmen wie etwa NewReno oder CUBIC auf Paketverlust reagieren, misst BBR die vorliegende Engpassbreite sowie RTT,
und bestimmt daraus die Sende-Rate, welche anschließend in dem Netzwerk eingesetzt wird. 
Da BBR nicht direkt auf Paketverlust reagiert, kommt es mit gut mit zufälligen Paketverlust zurecht, hat aber zeitgleich
Schwierigkeiten mit der Fairness was die Verteilung von Ressourcen angeht : 

% QUOTE

\begin{quote}
``Unfairness happens [\dots], which relates to different settings of round-trip times and buffer sizes.
Essentially, the reason for the unstable or unequal unfairness is the absence of responding mechanisms for bandwidth convergence.''\cite{tang24BBRns3}
\end{quote}
 

Die Fairness kann hierbei mit dem zwischen 0 und 1 liegenden Jain's Fairness (\textbf{JFI}) Index gemessen werden.\cite{DBLP:journals/corr/cs-NI-9809099}

\subsubsection{TCP NewReno}
Der TCP \textbf{NewReno} Algorithmus wurde erstmal 1999 mit dem RFC 2582 eingeführt.\cite{rfc2582}
NewReno ist ein \textit{Loss-Based} Algorithmus, das bedeutet der
Arbeitsmodus \textit{congestion avoidance} tritt ein, falls ein Paketverlust erkannt wird.
Das Wachstum des \texttt{cwnd} (vgl.\ref{cw-def})  ist hierbei linear gegenüber der Anzahl der Pakete.


\subsubsection{TCP Cubic}
\textbf{Cubic} ist ebenfalls ein \textit{Loss-Based} Algorithmus.

Die Wachstumsfunktion, welche anschließend die neue Größe des \textit{Congestion Window}
beschreibt, wird definiert als : $ W(t) = C(t-K)^3 + W_{max}$.  
Hierbei ist \textit{W} die größe des Congestion Windows, \textit{C} eine Cubic-Konstante, 
\textit{t} die Zeit seit dem letzten Paketverlust, und \textit{K} die Zeit, welche \textit{TCP Cubic} benötigt 
um wieder \textit{W\text{max}} zu erreichen.

Mit der Sensitivität auf Paketverlust $\beta$ kann \textit{K} wie folgt berechnet werden \cite{HArheeInjXuCUBIC} :

\[
K = \sqrt[3]{\frac{W_{\text{max}} \cdot \beta}{C}}     
\]


\subsubsection{TCP Vegas}
\textbf{Vegas} ist ein Avoidance-basierter CC-Algorithmus, welcher 1994 vorgestellt wurde.
Im Kapitel 5. von dem Buch \textit{TCP Congestion Control : A Systems Approach} wird beschrieben, dass Vegas den gemessenen Durchsatz 
von Paketen mit dem erwarteten Wert vegleicht. \cite{tcpccCh5}
Auf Basis dieses Vergleiches wird dann bestimmt, wie viele Pakete ohne Verluste verschickt werden können.

Der erwartete Wert ist hier der Idealwert von dem Durchsatz, welcher über das Netzwerk geesendet werden könnte, 
falls keine Warteschlange vorliegen würde. Dieser kann wie folgt bestimmt werden : 
$ ExpectedRate = \frac{\text{\texttt{cwnd}}}{BaseRTT}$ \cite{tcpccCh5}
wobei $BaseRTT$ die minimale RTT (vgl. \ref{rtt-def}) beschreibt.


\begin{figure}[ht] 
    \centering
    \includegraphics[height = 5cm]{./graphics/vegas.png}
    \caption{Beispiel von Vegas \texttt{cwnd} \& Vegleich von erwarteten und 
    tatsächlichen Durchsatz.\cite{tcpccCh5}} 
    \label{fig:vegasCWandThroughput}
\end{figure}

Abbildung \ref{fig:vegasCWandThroughput} visualisiert das \texttt{cwnd} (vgl. \ref{cw-def}) und die 
dazugehörigen Durchsätze (erwartet \& tatsächlich) für ein Beispiel Vegas Durchlauf.
Die in blau eingezeichnete Linie beschreibt den erwarteten Durchsatz, während die schwarz
gefärbte Linie den tatsächlichen Durchsatz darstellt.
 


\subsubsection{Merkmale der CC Algorithmen auf einen Blick}
Hier werden dem Leser unterschiedliche Merkmale von \textbf{CC} Algorithmen verständlich in einer 
Tabelle aufgelistet.

\begin{table}[ht]
\centering

\begin{tabular}{r|l|l|l}
   & \textbf{Algorithmus} & \textbf{Typ} & \textbf{Signal der Congestion avoidance} \\ \hline
\textbf{BBR} & a & b & c \\
\textbf{NewReno} & d & e & f \\
\textbf{Cubic} & g & h & i \\
\textbf{Vegas} & n & f & f 

\end{tabular}
\end{table}

\subsection{Definitionen}
Hier werden dem Leser einige Definitionen über die in dem Bericht vorkommenden Begriffe näher gebracht.

\subsubsection{Congestion Window} \label{cw-def}
Das \textit{Congestion Window}(\texttt{cwnd}) beschreibt die maximale Anzahl von Segmenten (Paketen) welche gleichzeitig über ein Netzwerk gesendet werden können, ohne 
dass Datenstau auftritt. Falls es zu Engpässen kommt, fällt der Verlauf von \texttt{cwnd}.

\subsubsection{Round-Trip Time} \label{rtt-def}

Der Round-Trip Time (\textbf{RTT})ist die Zeit von dem Absenden eines Segments bis zu dem Eintreffen der jeweiligen Bestätigungsnachricht \textit{\textbf{ACK}} beim Sender.



\clearpage
\section{Versuchsaufbau}

Mit einem Test innerhalb des Command Line Simulators \textit{NS-3.45}\cite{ns3-simu} lässt sich ein beliebieger CC-Algorithmus ausführen.


\textbf{Netzwerktopologie}

Zunächst definieren wir die Netzwerktopologie auf welcher die CC-Algorithmen
laufen werden.\cite{ns3BBR}
\small
\begin{verbatim}
            1000 Mbps           10 Mbps           1000 Mbps
  Sender -------------- R1 -------------- R2 -------------- Receiver
             5 ms                10 ms              5 ms
\end{verbatim}
So ist es möglich, einen Netzwerkstau zu simulieren, dieser bleibt für jeden Algorithmus gleich.

Durch das Verändern der folgenden \textit{C++} Codezeile der Datei \verb|tcp-bbr-example.cc| mit dem Namen des gewünschten Algorithmus lässt sich der Test unter gleichen Netzwerkbedingungen für die anderen Tesstfälle ausführen :

\small
\begin{verbatim}
[...]
    std::string tcpTypeId = "ALGO_NAME";     
[...]
\end{verbatim}
Mittels der Navigation in das Directory \textit{ns-3.45} per Kommandozeile und dem Befehl
\small
\begin{verbatim}
    ./ns3 run examples/tcp/tcp-bbr-example.cc
\end{verbatim}
lässt sich der jeweilige Testlauf ausführen.
 Die aufgezeichneten Informationen können mit dem im Anhang hinterlegten Skript visualisiert werden.


\begin{figure}[H]
    \centering

    \begin{subfigure}{0.40\textwidth}

        \includegraphics[width=\linewidth]{graphics/bbrCW.pdf}
        \caption{BBR}
        \label{fig:bbr}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.40\textwidth}
        \includegraphics[width=\linewidth]{graphics/newRenoCW.pdf}
        \caption{NewReno}
        \label{fig:newreno}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.40\textwidth}
        \includegraphics[width=\linewidth]{graphics/cubicCW.pdf}
        \caption{Cubic}
        \label{fig:cubic}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.40\textwidth}
        \includegraphics[width=\linewidth]{graphics/vegasCW.pdf}
        \caption{Vegas}
        \label{fig:vegas}
    \end{subfigure}

    \caption{Vergleich der aufgezeichneten Congestion Windows.}
    \label{fig:cwnd-all}
\end{figure}

\clearpage 
\subsection{Analyse der Ergebnisse}
Wie an den \textit{Congestion Window} Graphen erkennbar, besitzt jeder 
der vorgestellten Algorithmen eine eigene Herangehensweise was  das Regulieren 
von Datenstau angeht.
Die RTT wird bei ungefähr $40$ Milisekunden liegen, da die Verzögerung aufgrund
der Netzwerktopologie bei \texttt{5ms + 10ms + 5ms} in jede Richtung liegt. 

\subsection*{BBR (a)}

Das im Graph in Abbildung 1(a) gezeigte \texttt{cwnd} weist auf klare, periodische Einbrüche des Verlaufs auf, diese lassen
sich auf die Phase \textit{ProbeRTT} des Algorithmus zurückführen. Dies unterscheidet BBR von den anderen
CC-Algorithmen, da hier ein Einbruch im \texttt{cwnd} nicht direkt ein Hinweis auf Paketverlust ist, sondern jeweils eine 
gezielte Messung der RTT bedeutet. Mit jeder Messung wird eine neue minimale RTT bestimmt, und die Warteschlange von Paketen
kann am Engpass geleert werden.

\subsection*{NewReno (b)}

Der in Abbildung 1(b) aufgezeichnete Verlauf von NewReno zeigt im \texttt{cwnd} ein Sägezahn-ähnliches Muster. Hierbei lässt sich erst
die lineare Steigung und dann der abrupte Einbruch der Anzahl der gesendeten Paketen leicht erkennen.
Das \texttt{cwnd} wächst in der \textit{congestion avoidance} Phase bis zum nächsten Einbruch.
Nach dem Einbruch tritt der Algorithmus in eine \textit{Recovery} Phase ein, wobei der Graph erneut linear zunimmt.

\subsubsection*{Cubic (c)}

Mit dem in Abbildung 1(c) visualisierten Graphen kann der Leser das Arbeitsmuster von Cubic erkennen.
Ähnlich wie NewReno in Abbildung 1(b) reagiert Cubic auf Paketverluste, hat allerdings eine strengere Anstiegskurve,
da hier der Graph kubisch verläuft. Ebenfalls zu erkennen sind Plateaus, in denen für eine kurze Zeit das 
\texttt{cwnd} nicht ansteigt. Diese liegen an Orten, wo zuvor das $W_{max}$ erreicht wurde.

\subsection*{Vegas (d)}

In Abbildung 1 (d) wächst das \texttt{cwnd} ohne große Einbrüche. Dieser Verlauf passt zu Vegas, da der Algorithmus 
das \texttt{cwnd} nur langsam erhöht wenn ein Engpass erkannt wird. Somit wird die Warteschlange an Paketen klein gehalten.
Wie an dem Graphen erkennbar, fällt das \texttt{cwnd} Verhalten linear.


\section{Ergebnisse und Diskussion}
Aufgrund der vorher durchgeführten Analyse werden hier die daraus gewonnenen \texttt{cwnd}-Ergebnissen präsentiert. 

\textbf{BBR} weist periodisch auftretende Einbrüche auf, welche sich allerdings auf \textit{ProbeRTT} zurückführen lassen.
Grundsätzlich ist das Sendeverhalten von BBR stabil, und die auftretenden Warteschlangen werden regelmäßig abgebaut.
Bei mehreren, nebenläufigen Übertragungen hat BBR Schwierigkeiten mit der Fairness, allerdings wurden diese in den späteren
Versionen adressiert. Da wie beschreiben der Verlust von Paketen nicht das primäre Signal ist, eignet sich BBR für 
Netzwerke in denen oft ein zufälliger Verlust auftritt, wie etwa bei WLAN. \newline
\textbf{NewReno} welcher auch im Linux Kernel vertreten ist, hat eine lineare Steigung und abrupte Einbrüche.
Da dieser Algorithmus stark auf den Verlust von Paketen reagiert, kann es bei Netzwerken mit zufälligen Signalschwankungen
zu Unterauslastung kommen, hierbei wird aufgrund von ständig aufeinanderfolgenden \textit{congestion avoidance} Phasen
nicht die volle Bandbreite des Netzwerks ausgenutzt. \newline
\textbf{Cubic} kann durch die kubische Wachstumskurve effizient nach Einbrüchen des \texttt{cwnd} wieder die gewünschte 
Kapazität an Paketen wiederfinden. Heutzutage wurd Cubic in Linux, aber auch in Netzwerken mit hohen Bandbreiten verwendet.\cite{pandorafms} \newline
\textbf{Vegas} besitzt duch die langsame Steigung des \texttt{cwnd} eine niedrige Latenz.
Hierbei wird nicht direkt auf Verlust geachtet, sondern wie beschrieben die RTT gemessen, verglichen, und anschließend entschieden.



\section{Fazit und Schlussfolgerungen}
Ziel dieses Berichts war es die Staukontrollverfahren unter identischen Bedingungen zu vergleichen.
Dies ist mit \textbf{ns-3} gelungen, und die Algorithmen konnten in Form vom \texttt{cwnd} Graphen aufgezeichnet
werden.
Auch wenn diese Verfahren das gleiche Ziel befolgen, nämlich den Datenfluss von Paketen über das Netzwerk zu 
verwalten, tun Sie dies mit verschiedenen Vorgehensweisen. Es soll eine möglichst hohe Bandbreite gewährleistet
werden, und gleichzeitig kein Verlust von Paketen an Netzwerkschnittstellen erfolgen. Es ist klar, dass CC-Algorithmen
ein nötiges Bestandteil der heutigen Rechnernetze ist, und bleibt.


\section{Ausblick}
Um den Rahmen dieses Berichts einfach zu halten, habe Ich mich entschieden, nur das \texttt{cwnd} in den Vergleich 
einzubringen. Interessant wäre zusätzlich die Messung der Bandbreite, oder etwa im Fall von \textbf{BBR} mehrere Datenflüsse(\textit{Flows}) 
eizuführen, und diese mit \textbf{ns-3} und dem \textbf{JFI} auszuwerten. 



% Hier beginnt das Literaturverzeichnis
\clearpage
\renewcommand\refname{Literaturverzeichnis}
\bibliographystyle{IEEEtran}

\bibliography{literatur}
\addcontentsline{toc}{section}{Literaturverzeichnis}


% Hier beginnt der Anhang
\clearpage
\appendix
\part*{Anhang}

\addcontentsline{toc}{section}{Anhang}

\section{Zusätzliche Abbildungen}

\begin{figure}[ht]
    \centering
    \includegraphics[height=10cm]{graphics/3way.png}
    \caption{Detaillierte Darstellung des Three-Way Handshake.}
    \label{fig:three-way handshake}
\end{figure}



\section{GnuPlot Skript zur Erstellung der CWND Graphen}
Hier folgt das Skript mit dem die in Abbildung \ref{fig:cwnd-all} vorgestellten \texttt{cwnd} Graphen erstellt worden sind.

\begin{verbatim}
set terminal pdfcairo size 10cm,7cm enhanced font "Helvetica,14"
set output "cwnd.pdf"

set xlabel "Zeit (s)"
set ylabel "CWND (Pakete)"
set grid
set key top right

plot "cwnd.dat" using 1:2 with lines lw 2 lc rgb "red" title "CWND"
\end{verbatim}


\section{Nicht erfüllte Vorgaben}
Aufgrund des Mangels von unter anderem der Anzahl an komplexen Formeln und Tabellen zu dem Thema des Berichts folgen hier die 
restlichen Vorgaben.

\subsection{Formel von Bayes}
Die Bayessche Formel ist eine grundlegende Formel in der Statistik. Sie beschreibt die bedingte Wahrscheinlichkeit für
das Aufreten eines Ereignisses $A_k$ gegeben Ereignis $B$. 
Ereignis $A_k$ wird oft als die \textbf{\textit{a priori}} Wahrscheinlichkeit bezeichnet.

\[
Sei \; P(B)>0. \; A_1 \dot{\cup} \ldots \dot{\cup} A_n \;  =\Omega \; \text{Dann gilt :} \newline
\]

\[
P(A_k | B) = \frac{P(A_k)  \cdot P(B | A_k)}{\sum_{i=1}^{n}P(A_i  \cdot P(B | A_i))}
\]

\subsection{Beweis der Formel von Bayes}

Der Satz liefert : 
\[ 
P(A_k | B) = \frac{P(A_k \cap B)}{P(B)} = \frac{P(A_k) \cdot \frac{P(B \cap A_k)}{P(A_k)}} {P(B)} = \frac{P(A_k) \cdot P(B | A_k)}{ \sum_{i=1}^{n}P(A_i) \cdot P(B | A_i)}
\]

$\square$

\subsection{Komplexe Tabelle}

\begin{table}[ht]
    \centering

    \begin{adjustbox}{max width=0.8\textwidth}
    \rowcolors{2}{gray!10}{white}


        \begin{tabular}{@{} l l c c c @{}}
        \toprule

        \textbf{Programmiersprache} & \textbf{Bemerkung} & \textbf{Funktional} & \textbf{Prozedural} & \textbf{Objektorientiert} \\
        \midrule
            
            Java & JVM & \xmark & \xmark & \cmark   \\
            OCamkl & Nachfolger von StandardML & \cmark & \xmark & \xmark \\
            Lisp & Common Lisp & \cmark & \xmark & \xmark \\
            Pascal & ISO Pascal & \xmark & \cmark & \xmark \\ 
            C & Low-Level & \xmark & \cmark & \xmark \\

        \bottomrule

            
        \end{tabular}
    
    \end{adjustbox}

    \caption{Einige Programmiersprachen und ihre Einordnung ob Sie Funktional, Prozedural,
     oder Objektorientiert sind.}
    \label{tab:compar}
    
\end{table}


\end{document}

